package org.rnd.jmagic.engine;

import org.rnd.jmagic.engine.generators.*;

/**
 * Represents a type of continuous effect (setting color, changing
 * power/toughness, etc).
 */
public abstract class ContinuousEffectType
{
	// Because of the nature of a continuous effect, many of these effect types
	// are looking for SetGenerators in their parameters. When constructing an
	// effect that uses one of those types, you'll have to construct
	// SetGenerators that evaluate to other SetGenerators. The parameters that
	// require this are noted with "(Requires the double-generator construct)".

	/**
	 * Each ContinuousEffectType must be applied in one of the following layers.
	 * This is the order the effects are applied. Effects are applied in
	 * time-stamp order within each layer and effects generated by
	 * characteristic defining abilities (CDA) are always applied before non-CDA
	 * effects.
	 */
	public enum Layer
	{
		/**
		 * There is no actual layer 0 but Wizards of the Coast occasionally
		 * makes new rules (like {@link ContinuousEffectType#PAIR}) that act
		 * exactly like normal continuous effects except that they have to apply
		 * before all other continuous effects (like if a creature with
		 * {@link org.rnd.jmagic.abilities.keywords.Soulbond} had
		 * "This creature is a copy of the creature it's paired with").
		 */
		LAYER_ZERO
		{
			@Override
			public boolean checkDependencies()
			{
				return false;
			}

			@Override
			public boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY)
			{
				throw new UnsupportedOperationException("Tried to check a dependency in layer zero.");
			}
		},
		/**
		 * 613.1a Layer 1: Copy effects are applied. See rule 706,
		 * "Copying Objects."
		 */
		COPY
		{
			@Override
			public boolean checkDependencies()
			{
				return false;
			}

			@Override
			public boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY)
			{
				throw new UnsupportedOperationException("Tried to check a dependency in the copy-effects layer.");
			}
		},
		/**
		 * 613.1b Layer 2: Control-changing effects are applied.
		 */
		CONTROL_CHANGE
		{
			@Override
			public boolean checkDependencies()
			{
				return true;
			}

			@Override
			public boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY)
			{
				return afterY.controllerID != afterXandY.controllerID;
			}
		},
		/**
		 * 613.1c Layer 3: Text-changing effects are applied. See rule 612,
		 * "Text-Changing Effects."
		 */
		TEXT_CHANGE
		{
			@Override
			public boolean checkDependencies()
			{
				return false;
			}

			@Override
			public boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY)
			{
				throw new UnsupportedOperationException("Tried to check a dependency in the text-change effects layer.");
			}
		},
		/**
		 * 613.1d Layer 4: Type-changing effects are applied. This includes
		 * effects that change an object's card type, subtype, and/or supertype.
		 */
		TYPE_CHANGE
		{
			@Override
			public boolean checkDependencies()
			{
				return true;
			}

			@Override
			public boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY)
			{
				if(enumDependencyCheck(untouched.getTypes(), afterX.getTypes(), afterY.getTypes(), afterXandY.getTypes()))
					return true;
				if(enumDependencyCheck(untouched.getSubTypes(), afterX.getSubTypes(), afterY.getSubTypes(), afterXandY.getSubTypes()))
					return true;
				if(enumDependencyCheck(untouched.getSuperTypes(), afterX.getSuperTypes(), afterY.getSuperTypes(), afterXandY.getSuperTypes()))
					return true;
				return false;
			}
		},
		/**
		 * 613.1e Layer 5: Color-changing effects are applied.
		 */
		COLOR_CHANGE
		{
			@Override
			public boolean checkDependencies()
			{
				return true;
			}

			@Override
			public boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY)
			{
				return enumDependencyCheck(untouched.getColors(), afterX.getColors(), afterY.getColors(), afterXandY.getColors());
			}
		},
		/**
		 * 613.1f Layer 6: Ability-adding and ability-removing effects are
		 * applied.
		 */
		ABILITY_ADD_OR_REMOVE
		{
			@Override
			public boolean checkDependencies()
			{
				return true;
			}

			@Override
			public boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY)
			{
				java.util.Collection<Class<?>> untouchedClasses = new java.util.ArrayList<Class<?>>();
				// -1 on an instant or sorcery represents its spell ability.
				for(int i: untouched.getAbilityIDsInOrder())
					if(i != -1)
						untouchedClasses.add(untouched.state.get(i).getClass());
				java.util.Collection<Class<?>> afterXClasses = new java.util.ArrayList<Class<?>>();
				for(int i: afterX.getAbilityIDsInOrder())
					if(i != -1)
						afterXClasses.add(afterX.state.get(i).getClass());
				java.util.Collection<Class<?>> afterYClasses = new java.util.ArrayList<Class<?>>();
				for(int i: afterY.getAbilityIDsInOrder())
					if(i != -1)
						afterYClasses.add(afterY.state.get(i).getClass());
				java.util.Collection<Class<?>> afterXandYClasses = new java.util.ArrayList<Class<?>>();
				for(int i: afterXandY.getAbilityIDsInOrder())
					if(i != -1)
						afterXandYClasses.add(afterXandY.state.get(i).getClass());

				java.util.Collection<Class<?>> addedToUntouchedByY = new java.util.ArrayList<Class<?>>(afterYClasses);
				addedToUntouchedByY.removeAll(untouchedClasses);

				java.util.Collection<Class<?>> addedToXByY = new java.util.ArrayList<Class<?>>(afterXandYClasses);
				addedToXByY.removeAll(afterXClasses);

				if(!addedToXByY.equals(addedToUntouchedByY))
					return true;

				// at this point we have no use for the original "untouched" and
				// "afterX" class lists so references are fine
				java.util.Collection<Class<?>> removedFromUntouchedByY = untouchedClasses;
				removedFromUntouchedByY.removeAll(afterYClasses);

				java.util.Collection<Class<?>> removedFromXByY = afterXClasses;
				removedFromXByY.removeAll(afterXandYClasses);

				if(!removedFromXByY.equals(removedFromUntouchedByY))
					return true;

				return false;
			}
		},
		/**
		 * 613.1g Layer 7: Power- and/or toughness-changing effects are applied.
		 */
		POWER_AND_TOUGHNESS
		{
			@Override
			public boolean checkDependencies()
			{
				return false;
			}

			@Override
			public boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY)
			{
				throw new UnsupportedOperationException("Tried to check a dependency in the power and toughness layer, instead of one of the sublayers.");
			}
		},
		/**
		 * 613.9. Some continuous effects affect players rather than objects.
		 * ... All such effects are applied in timestamp order after the
		 * determination of objects' characteristics.
		 */
		PLAYER
		{
			@Override
			public boolean checkDependencies()
			{
				return false;
			}

			@Override
			public boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY)
			{
				throw new UnsupportedOperationException("Tried to check a dependency in the player layer.");
			}
		},
		/**
		 * 613.10. Some continuous effects affect game rules rather than
		 * objects. For example, effects may modify a player's maximum hand
		 * size, or say that a creature is indestructible. These effects are
		 * applied after all other continuous effects have been applied.
		 */
		RULE_CHANGE
		{
			@Override
			public boolean checkDependencies()
			{
				return false;
			}

			@Override
			public boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY)
			{
				throw new UnsupportedOperationException("Tried to check a dependency in the rule-change layer.");
			}
		},
		/**
		 * This is a fake layer for replacement effects. It doesn't exist in the
		 * rules; replacement effects don't "interact" in the same way that
		 * other effects do.
		 */
		REPLACEMENT_EFFECTS
		{
			@Override
			public boolean checkDependencies()
			{
				return false;
			}

			@Override
			public boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY)
			{
				throw new UnsupportedOperationException("Tried to check a dependency in the replacement effects layer.");
			}
		};

		/**
		 * @return Whether dependencies need to be checked in this layer.
		 */
		public abstract boolean checkDependencies();

		/**
		 * Used to detect dependencies between effects.
		 * {@link DependencyCalculator} will apply effect X and effect Y to the
		 * same object in different game states, then pass those objects to this
		 * method to see if the object indicates a dependency. If what Y
		 * "does to" an object changes based on whether X is applied to that
		 * object, then Y is dependent on X.
		 *
		 * @param untouched The object before either effect is applied.
		 * @param afterX The object after only effect X is applied.
		 * @param afterY The object after only effect Y is applied.
		 * @param afterXandY The object after effect X and Y are applied, in
		 * that order.
		 *
		 * @return Whether the objects given indicate that effect Y depends on
		 * effect X. The objects given will be the same object, but in different
		 * game states.
		 *
		 * @throws UnsupportedOperationException if checkDependencies is false
		 * for this layer.
		 *
		 * @see SubLayer#objectsIndicateDependency
		 */
		public abstract boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY);

		protected <T extends Enum<T>> boolean enumDependencyCheck(java.util.Set<T> untouched, java.util.Set<T> afterX, java.util.Set<T> afterY, java.util.Set<T> afterXandY)
		{
			java.util.EnumSet<T> addedToUntouchedByY = java.util.EnumSet.copyOf(afterY);
			addedToUntouchedByY.removeAll(untouched);

			java.util.EnumSet<T> addedToXByY = java.util.EnumSet.copyOf(afterXandY);
			addedToXByY.removeAll(afterX);

			if(!addedToXByY.equals(addedToUntouchedByY))
				return true;

			java.util.EnumSet<T> removedFromUntouchedByY = java.util.EnumSet.copyOf(untouched);
			removedFromUntouchedByY.removeAll(afterY);

			java.util.EnumSet<T> removedFromXByY = java.util.EnumSet.copyOf(afterX);
			removedFromXByY.removeAll(afterXandY);

			if(!removedFromXByY.equals(removedFromUntouchedByY))
				return true;

			return false;
		}
	}

	public enum Parameter
	{
		ABILITY, ACTION, ATTACKING, COLOR, CONTROLLER, COPY, COST, DEFENDING, EFFECT, EVENT, EXEMPT, FROM, NAME, NUMBER, OBJECT, ORIGINAL, PERMISSION, PLAYER, POWER, PROHIBITION, RANGE, REMOVED_OBJECTS, RESTRICTION, RETAIN, TO, TOUGHNESS, TYPE,
	}

	/**
	 * This class exists solely so that ContinuousEffects can store it in a Set
	 * and DependencyGraph can call getOne to retrieve it specifically.
	 */
	public static class RemovedObjects extends Set
	{
		private static final long serialVersionUID = 1L;
	}

	/**
	 * For effects in the POWER_AND_TOUGHNESS layer, effects must be applied in
	 * one of the following sub-layers
	 */
	public enum SubLayer
	{
		/**
		 * 613.3b Layer 7b: Effects that set power and/or toughness to a
		 * specific number or value are applied.
		 */
		SET
		{
			@Override
			public boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY)
			{
				return afterY.getPower() != afterXandY.getPower() || afterY.getToughness() != afterXandY.getToughness();
			}
		},
		/**
		 * 613.3c Layer 7c: Effects that modify power and/or toughness (but
		 * don't set power and/or toughness to a specific number or value) are
		 * applied.
		 */
		MODIFY
		{
			@Override
			public boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY)
			{
				return false;
				// return ((afterX.power - afterXandY.power) == (untouched.power
				// - afterY.power)) || ((afterX.toughness -
				// afterXandY.toughness) == (untouched.toughness -
				// afterY.toughness));
			}
		},
		/**
		 * 613.3d Layer 7d: Power and/or toughness changes from counters are
		 * applied. See rule 121.
		 * <p>
		 * Do not use this layer directly; it is a placeholder.
		 */
		COUNTERS
		{
			@Override
			public boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY)
			{
				throw new UnsupportedOperationException("Tried to check a dependency in the counters sublayer.");
			}
		},
		/**
		 * 613.3e Layer 7e: Effects that switch a creature's power and toughness
		 * are applied. Such effects take the value of power and apply it to the
		 * creature's toughness, and take the value of toughness and apply it to
		 * the creature's power.
		 */
		SWITCH
		{
			@Override
			public boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY)
			{
				return false;
			}
		};

		/**
		 * Used to detect dependencies between effects.
		 * {@link DependencyCalculator} will apply effect X and effect Y to the
		 * same object in different game states, then pass those objects to this
		 * method to see if the object indicates a dependency. If what Y
		 * "does to" an object changes based on whether X is applied to that
		 * object, then Y is dependent on X.
		 *
		 * @param untouched The object before either effect is applied.
		 * @param afterX The object after only effect X is applied.
		 * @param afterY The object after only effect Y is applied.
		 * @param afterXandY The object after effect X and Y are applied, in
		 * that order.
		 *
		 * @return Whether the objects given indicate that effect Y depends on
		 * effect X. The objects given will be the same object, but in different
		 * game states.
		 *
		 * @throws UnsupportedOperationException if checkDependencies is false
		 * for this layer.
		 *
		 * @see Layer#objectsIndicateDependency
		 */
		public abstract boolean objectsIndicateDependency(GameObject untouched, GameObject afterX, GameObject afterY, GameObject afterXandY);
	}

	/**
	 * "The Chain Veil" effect.
	 * 
	 * @eparam OBJECT which planeswalkers can have their loyalty abilities
	 * activated again.
	 */
	public static final ContinuousEffectType ACTIVATE_ADDITIONAL_LOYALTY_ABILITY = new ContinuousEffectType("ACTIVATE_ADDITIONAL_LOYALTY_ABILITY")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			for(GameObject o: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
				o.maxLoyaltyActivations++;
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the object(s) who get the ability
	 * @eparam ABILITY: an {@link AbilityFactory} which should be used to
	 * construct the ability to add to the objects
	 */
	public static final ContinuousEffectType ADD_ABILITY_TO_OBJECT = new ContinuousEffectType("ADD_ABILITY_TO_OBJECT")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			java.util.Set<AbilityFactory> factories = parameters.get(Parameter.ABILITY).getAll(AbilityFactory.class);
			boolean isFCE = effect instanceof FloatingContinuousEffect;
			FloatingContinuousEffect fce = isFCE ? (FloatingContinuousEffect)effect : null;

			// Any created abilities should be created in the physical state
			for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
			{
				for(AbilityFactory factory: factories)
				{
					Game.GrantedAbilityKey key = new Game.GrantedFactoryAbilityKey(factory, effect.getSourceObject(), factory.clazz(), object.ID);
					Identified physicalAbility;
					if(state.game.grantedAbilities.containsKey(key))
					{
						physicalAbility = state.game.physicalState.get(state.game.grantedAbilities.get(key));
					}
					else
					{
						physicalAbility = factory.create(state.game.physicalState, effect.getSourceObject());
						state.game.grantedAbilities.put(key, physicalAbility.ID);
					}

					Identified instance;
					if(state.containsIdentified(physicalAbility.ID))
						instance = state.copyForEditing(physicalAbility);
					else
						instance = physicalAbility.clone(state);

					if(instance instanceof NonStaticAbility)
					{
						NonStaticAbility ability = (NonStaticAbility)instance;
						Identified sourceObject = effect.getSourceObject();
						if(sourceObject != null)
							ability.grantedByID = sourceObject.ID;
						object.addAbility(ability);
					}
					else if(instance instanceof Keyword)
					{
						if(isFCE && fce.dontGrant.containsKey(instance.getClass()) && fce.dontGrant.get(instance.getClass()).contains(object.ID))
							continue;

						Keyword newAbility = (Keyword)instance;
						newAbility.createdByTimestamp = effect.getTimestamp();
						newAbility.grantedByID = effect.ID;
						object.addAbility(newAbility);
					}
					else if(instance instanceof StaticAbility)
					{
						StaticAbility newAbility = (StaticAbility)instance;

						// Make sure the static ability's continuous effect
						// is in this state
						if(!state.containsIdentified(newAbility.effectID))
							((StaticAbility)physicalAbility).getEffect().clone(state);

						newAbility.createdByTimestamp = effect.getTimestamp();
						newAbility.grantedByID = effect.ID;
						object.addAbility(newAbility);
					}
				}
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.ABILITY_ADD_OR_REMOVE;
		}
	};

	/**
	 * @eparam PLAYER: the player getting the ability
	 * @eparam ABILITY: an {@link AbilityFactory} which should be used to
	 * construct the ability to add to the player
	 */
	public static final ContinuousEffectType ADD_ABILITY_TO_PLAYER = new ContinuousEffectType("ADD_ABILITY_TO_PLAYER")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.PLAYER;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			java.util.Set<AbilityFactory> factories = parameters.get(Parameter.ABILITY).getAll(AbilityFactory.class);

			// Any created abilities should be created in the physical state
			for(Player player: parameters.get(Parameter.PLAYER).getAll(Player.class))
			{
				for(AbilityFactory factory: factories)
				{
					Game.GrantedAbilityKey key = new Game.GrantedFactoryAbilityKey(factory, effect.getSourceObject(), factory.clazz(), player.ID);
					Identified physicalAbility;
					if(state.game.grantedAbilities.containsKey(key))
					{
						physicalAbility = state.game.physicalState.get(state.game.grantedAbilities.get(key));
					}
					else
					{
						physicalAbility = factory.create(state.game.physicalState, effect.getSourceObject());
						state.game.grantedAbilities.put(key, physicalAbility.ID);
					}

					Identified instance;
					if(state.containsIdentified(physicalAbility.ID))
						instance = state.copyForEditing(physicalAbility);
					else
						instance = physicalAbility.clone(state);

					if(instance.isKeyword())
						player.addAbility((Keyword)instance);
					else if(instance.isStaticAbility())
						player.addAbility((StaticAbility)instance);
					else if(instance.isActivatedAbility() || instance.isTriggeredAbility())
						player.addAbility((NonStaticAbility)instance);
				}
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.PLAYER;
		}
	};

	/**
	 * @eparam OBJECT: the object(s) to modify numModes of
	 * @eparam NUMBER: the number to add to numModes (leave empty to add the
	 * objects number of modes)
	 */
	public static final ContinuousEffectType ADD_CHOOSABLE_NUMBER_OF_MODES = new ContinuousEffectType("ADD_CHOOSABLE_NUMBER_OF_MODES")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Set number = parameters.get(Parameter.NUMBER);
			org.rnd.util.NumberRange range = (number.isEmpty() ? null : EventType.getRange(number));

			for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
			{
				if(range == null)
					object.getNumModes()[0].add(object.getModes()[0].size());
				else
					object.getNumModes()[0].add(range);
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the object(s) whose color to change
	 * @eparam COLOR: the color(s) to be added
	 */
	public static final ContinuousEffectType ADD_COLOR = new ContinuousEffectType("ADD_COLOR")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			java.util.Set<Color> colors = parameters.get(Parameter.COLOR).getAll(Color.class);
			for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
				object.addColors(colors);
		}

		@Override
		public Layer layer()
		{
			return Layer.COLOR_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the object(s) whose types to change
	 * @eparam TYPE: the type(s), subtype(s), and/or supertype(s) to be added
	 */
	public static final ContinuousEffectType ADD_TYPES = new ContinuousEffectType("ADD_TYPES")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Set allTypes = parameters.get(Parameter.TYPE);

			java.util.Set<SubType> basics = SubType.getBasicLandTypes();

			java.util.Set<SuperType> superTypes = allTypes.getAll(SuperType.class);
			java.util.Set<Type> types = allTypes.getAll(Type.class);
			java.util.Set<SubType> subTypes = allTypes.getAll(SubType.class);

			for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
			{
				boolean wasPlaneswalker = object.getTypes().contains(Type.PLANESWALKER);
				java.util.Map<SubType, Boolean> wasBasic = new java.util.HashMap<SubType, Boolean>();
				for(SubType basic: basics)
					wasBasic.put(basic, object.getSubTypes().contains(basic));

				object.addSuperTypes(superTypes);
				object.addTypes(types);

				// 205.3d
				if(!subTypes.isEmpty())
				{
					java.util.Set<SubType> subTypesForThisObject = java.util.EnumSet.copyOf(subTypes);
					java.util.Iterator<SubType> i = subTypesForThisObject.iterator();
					while(i.hasNext())
						if(java.util.Collections.disjoint(i.next().getTypes(), object.getTypes()))
							i.remove();
					object.addSubTypes(subTypesForThisObject);
				}

				if(!wasPlaneswalker && object.getTypes().contains(Type.PLANESWALKER))
					object.addAbility(state.game.getLoyaltyCountersAbility(object.ID));
				for(java.util.Map.Entry<SubType, Boolean> entry: wasBasic.entrySet())
					if(!entry.getValue() && object.getSubTypes().contains(entry.getKey()))
						object.addAbility(state.game.getIntrinsic(entry.getKey(), object.ID));
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.TYPE_CHANGE;
		}
	};

	/**
	 * DAMN YOU SEEDBORN MUSE. DAMN YOU UNDISCOVERED PARADISE. DAMN YOU BOTH TO
	 * HELL.
	 *
	 * @eparam EVENT: the events to add to the extra events list
	 */
	public static final ContinuousEffectType ADD_UNTAP_EVENT = new ContinuousEffectType("ADD_UNTAP_EVENT")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Event e = parameters.get(Parameter.EVENT).getOne(EventFactory.class).createEvent(state.game, (GameObject)effect.getSourceObject());
			state.extraEvents.add(e);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam COST: A CostCollection object describing the alternate cost
	 * @eparam PLAYER: Who may pay the alternate cost
	 * @eparam OBJECT: The object to add the alternate cost to
	 */
	public static final ContinuousEffectType ALTERNATE_COST = new ContinuousEffectType("ADD_ALTERNATE_COST")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			CostCollection cost = parameters.get(Parameter.COST).getOne(CostCollection.class);
			if(cost == null)
				throw new UnsupportedOperationException("No alternate cost specified in " + effect + ".");
			java.util.Set<Player> players = parameters.get(Parameter.PLAYER).getAll(Player.class);

			for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
			{
				if(object.alternateCosts == null)
					object.alternateCosts = new java.util.HashSet<AlternateCost>();
				object.alternateCosts.add(new AlternateCost(cost, players));
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam COST this isn't actually a cost :-P an instance of a class
	 * extending {@link AlternateManaPayment}
	 * @eparam OBJECT the object (singular!) that can be paid for via the
	 * alternate payment
	 */
	public static final ContinuousEffectType ALTERNATE_PAYMENT = new ContinuousEffectType("ALTERNATE_PAYMENT")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			GameObject object = parameters.get(Parameter.OBJECT).getOne(GameObject.class);
			for(AlternateManaPayment amp: parameters.get(Parameter.COST).getAll(AlternateManaPayment.class))
			{
				if(object.alternatePayments == null)
					object.alternatePayments = new java.util.HashSet<>();
				object.alternatePayments.add(amp);
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the object to be modified
	 */
	public static final ContinuousEffectType ATTACK_AS_THOUGH_DOESNT_HAVE_DEFENDER = new ContinuousEffectType("ATTACK_AS_THOUGH_DOESNT_HAVE_DEFENDER")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
			{
				object.setAttacksWithDefender(true);
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * No parameters. This just sets the 'Doran Flag' in the state to true.
	 */
	public static final ContinuousEffectType ASSIGN_COMBAT_DAMAGE_USING_TOUGHNESS = new ContinuousEffectType("ASSIGN_COMBAT_DAMAGE_USING_TOUGHNESS")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			state.assignCombatDamageUsingToughness = true;
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam COST: The cost, per creature in the OBJECT parameter, each
	 * creature's controller must pay to attack with it.
	 * @eparam NUMBER: The number of times the player must pay the cost
	 * (optional; default = 1) (NOTE: read COST!! do not put the number of
	 * attacking creatures here!)
	 * @eparam OBJECT: The creatures this effect applies to. (Optional; default
	 * = all creatures) (does not use the double-generator idiom)
	 * @eparam PLAYER: The player who, if attacked, will invoke this cost to
	 * attack. (Optional; default = all players)
	 */
	public static final ContinuousEffectType ATTACKING_COST = new ContinuousEffectType("ATTACKING_COST")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Set cost = parameters.get(Parameter.COST);
			if(cost == null)
				throw new UnsupportedOperationException("No cost to attack specified in " + effect + ".");
			int number = 1;
			if(parameters.containsKey(Parameter.NUMBER))
				number = parameters.get(Parameter.NUMBER).getOne(Integer.class);

			Set creatures = parameters.get(Parameter.OBJECT);
			Set players = parameters.get(Parameter.PLAYER);

			state.attackingCosts.add(new AttackingCost(state, number, cost, creatures, players, effect.getSourceObject().ID));
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam ATTACKING: the creatures that must attack each turn, if able
	 * @eparam PLAYER: the player or planeswalker those creatures must attack
	 * (default is any player or planeswalker)
	 */
	public static final ContinuousEffectType ATTACKING_REQUIREMENT = new ContinuousEffectType("ATTACKING_REQUIREMENT")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			if(parameters.containsKey(Parameter.PLAYER))
			{
				Identified whoToAttack = parameters.get(Parameter.PLAYER).getOne(Identified.class);
				for(GameObject attacking: parameters.get(Parameter.ATTACKING).getAll(GameObject.class))
					state.attackingRequirements.add(new AttackingRequirement(attacking, whoToAttack));
			}
			else
				for(GameObject attacking: parameters.get(Parameter.ATTACKING).getAll(GameObject.class))
					state.attackingRequirements.add(new AttackingRequirement(attacking));
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam RESTRICTION: the SetGenerator representing the restriction. If it
	 * evaluates to empty, this restriction is satisfied; otherwise this
	 * restriction is violated. (Requires double-generator idiom)
	 * @eparam ABILITY: if present, this restriction comes from the
	 * {@link org.rnd.jmagic.abilities.keywords.Defender} ability. Only Defender
	 * gets to use this, obv obv obv
	 */
	public static final ContinuousEffectType ATTACKING_RESTRICTION = new ContinuousEffectType("ATTACKING_RESTRICTION")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Identified sourceObject = effect.getSourceObject();
			boolean defender = parameters.containsKey(Parameter.ABILITY);
			SetGenerator restriction = parameters.get(Parameter.RESTRICTION).getOne(SetGenerator.class);

			if(restriction == null)
				throw new NullPointerException("ATTACKING_RESTRICTION.RESTRICTION didn't contain a SetGenerator");

			CombatRestriction r = new CombatRestriction(restriction, sourceObject);
			if(defender)
				r.fromDefender();
			state.attackingRestrictions.add(r);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * 103.5. Once all players have kept their opening hands, if any cards in
	 * the starting player's hand allow that player to begin the game with those
	 * cards on the battlefield, he or she may put any or all of them onto the
	 * battlefield. Then each other player in turn order may do the same.
	 *
	 * @eparam EVENT: An event putting the object onto the battlefield.
	 * [optional -- By default, a simple PUT_ONTO_BATTLEFIELD event will be
	 * generated; you'll need to specify this if it's something more complex,
	 * e.g. Gemstone Caverns's luck counter event.]
	 * @eparam ACTION: An event to be performed "if you do" begin the game with
	 * the object on the battlefield. [optional; default = no event]
	 */
	public static final ContinuousEffectType BEGIN_THE_GAME_EFFECT = new ContinuousEffectType("BEGIN_THE_GAME_EFFECT")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			if(state.currentTurn() != null)
				return;

			GameObject toPut = (GameObject)effect.getSourceObject();

			if(parameters.containsKey(Parameter.EVENT))
				toPut.beginTheGameEffect = parameters.get(Parameter.EVENT).getOne(EventFactory.class);
			else
			{
				EventFactory beginTheGameOnTheBattlefield = new EventFactory(EventType.PUT_ONTO_BATTLEFIELD_UNDER_OWNER_CONTROL, "Begin the game with " + toPut + " on the battlefield.");
				beginTheGameOnTheBattlefield.parameters.put(EventType.Parameter.CAUSE, Identity.instance(toPut));
				beginTheGameOnTheBattlefield.parameters.put(EventType.Parameter.OBJECT, Identity.instance(toPut));
				toPut.beginTheGameEffect = beginTheGameOnTheBattlefield;
			}

			if(parameters.containsKey(Parameter.ACTION))
				toPut.beginTheGameConsequence = parameters.get(Parameter.ACTION).getOne(EventFactory.class);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam COST: The cost, per creature in the OBJECT parameter, each
	 * creature's controller must pay to block with it.
	 * @eparam NUMBER: The number of times the player must pay the cost
	 * (optional; default = 1) (NOTE: read COST!! do not put the number of
	 * attacking creatures here!)
	 * @eparam OBJECT: The creatures this effect applies to. (Optional; default
	 * = all creatures) (does not use the double-generator idiom)
	 */
	public static final ContinuousEffectType BLOCKING_COST = new ContinuousEffectType("BLOCKING_COST")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Set cost = parameters.get(Parameter.COST);
			if(cost == null)
				throw new UnsupportedOperationException("No cost to block specified in " + effect + ".");
			int number = 1;
			if(parameters.containsKey(Parameter.NUMBER))
				number = parameters.get(Parameter.NUMBER).getOne(Integer.class);

			Set creatures = parameters.get(Parameter.OBJECT);

			state.blockingCosts.add(new BlockingCost(state, number, cost, creatures));
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam ATTACKING: the set of creatures that can be blocked to satisfy
	 * this requirement (optional; must be specified if DEFENDING is omitted;
	 * default is all creatures)
	 * @eparam DEFENDING: the set of creatures that can block to satisfy this
	 * requirement (optional; must be specified if ATTACKING is omitted; default
	 * is all creatures)
	 * @eparam RANGE: the number of creatures from the blocking set allowed to
	 * block a creature from the attacking set in order to satisfy this
	 * requirement (optional; must be a NumberRange if specified; default is
	 * from 1 to infinity)
	 */
	public static final ContinuousEffectType BLOCKING_REQUIREMENT = new ContinuousEffectType("BLOCKING_REQUIREMENT")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			if(!parameters.containsKey(Parameter.ATTACKING) && !parameters.containsKey(Parameter.DEFENDING))
				throw new UnsupportedOperationException("Must specify one of " + Parameter.ATTACKING + " or " + Parameter.DEFENDING + " as parameters to " + BLOCKING_REQUIREMENT);

			java.util.Set<GameObject> attacking;
			if(parameters.containsKey(Parameter.ATTACKING))
				attacking = parameters.get(Parameter.ATTACKING).getAll(GameObject.class);
			else
				attacking = CreaturePermanents.instance().evaluate(state, null).getAll(GameObject.class);

			org.rnd.util.NumberRange range;
			if(parameters.containsKey(Parameter.RANGE))
				range = parameters.get(Parameter.RANGE).getOne(org.rnd.util.NumberRange.class);
			else
				range = new org.rnd.util.NumberRange(1, null);

			java.util.Set<GameObject> defending;
			if(parameters.containsKey(Parameter.DEFENDING))
				defending = parameters.get(Parameter.DEFENDING).getAll(GameObject.class);
			else
				defending = CreaturePermanents.instance().evaluate(state, null).getAll(GameObject.class);

			state.blockingRequirements.add(new BlockingRequirement(attacking, range, defending));
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam ATTACKING: the set of creatures that can be blocked to satisfy
	 * this requirement
	 * @eparam DEFENDING: the set of creatures that must block to satisfy this
	 * requirement
	 */
	public static final ContinuousEffectType BLOCKING_REQUIREMENT_FOR_EACH_DEFENDING_CREATURE = new ContinuousEffectType("BLOCKING_REQUIREMENT_FOR_EACH_DEFENDING_CREATURE")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			org.rnd.util.NumberRange oneToOne = new org.rnd.util.NumberRange(1, 1);
			java.util.Set<GameObject> attacking = parameters.get(Parameter.ATTACKING).getAll(GameObject.class);
			for(GameObject defending: parameters.get(Parameter.DEFENDING).getAll(GameObject.class))
			{
				java.util.Collection<GameObject> defendingCollection = new java.util.LinkedList<GameObject>();
				defendingCollection.add(defending);
				state.blockingRequirements.add(new BlockingRequirement(attacking, oneToOne, defendingCollection));
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam RESTRICTION: the SetGenerator representing the restriction. If it
	 * evaluates to empty, this restriction is satisfied; otherwise this
	 * restriction is violated. (Requires double-generator idiom)
	 */
	public static final ContinuousEffectType BLOCKING_RESTRICTION = new ContinuousEffectType("BLOCKING_RESTRICTION")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			SetGenerator restriction = parameters.get(Parameter.RESTRICTION).getOne(SetGenerator.class);
			if(restriction == null)
				throw new NullPointerException("BLOCKING_RESTRICTION.RESTRICTION didn't contain a SetGenerator");
			state.blockingRestrictions.add(new CombatRestriction(restriction, effect.getSourceObject()));
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: The objects which can block an additional creature.
	 * @eparam NUMBER: The number of additional creatures OBJECT can block.
	 * [Optional; default is 1]
	 */
	public static final ContinuousEffectType CAN_BLOCK_AN_ADDITIONAL_CREATURE = new ContinuousEffectType("CAN_BLOCK_AN_ADDITIONAL_CREATURE")
	{

		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			int num = 1;
			if(parameters.containsKey(Parameter.NUMBER))
				num = Sum.get(parameters.get(Parameter.NUMBER));
			for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
				if(object.getMaximumBlocks() != -1)
					object.setMaximumBlocks(object.getMaximumBlocks() + num);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: The objects which can block any number of creatures.
	 */
	public static final ContinuousEffectType CAN_BLOCK_ANY_NUMBER_OF_CREATURES = new ContinuousEffectType("CAN_BLOCK_ANY_NUMBER_OF_CREATURES")
	{

		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
				object.setMaximumBlocks(-1);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the objects or players affected by this effect
	 * @eparam RESTRICTION: a SetPattern (just one!) describing what the objects
	 * can't be attached by
	 */
	public static final ContinuousEffectType CANT_BE_ATTACHED_BY = new ContinuousEffectType("CANT_BE_ATTACHED_BY")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			SetPattern restriction = parameters.get(Parameter.RESTRICTION).getOne(SetPattern.class);
			for(AttachableTo t: parameters.get(Parameter.OBJECT).getAll(AttachableTo.class))
				t.cantBeAttachedBy(restriction);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};
	/**
	 * @eparam OBJECT: the objects or players affected by this effect
	 * @eparam RESTRICTION: a SetPattern (just one!) describing what the objects
	 * can't be attached to
	 */
	public static final ContinuousEffectType CANT_BE_ATTACHED_TO = new ContinuousEffectType("CANT_BE_ATTACHED_BY")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			SetPattern restriction = parameters.get(Parameter.RESTRICTION).getOne(SetPattern.class);
			for(GameObject t: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
				t.cantBeAttachedTo(restriction);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};
	/**
	 * @eparam OBJECT: the objects or players affected by this effect
	 * @eparam RESTRICTION: a SetPattern (just one!) describing what the objects
	 * can't be the target of
	 */
	public static final ContinuousEffectType CANT_BE_THE_TARGET_OF = new ContinuousEffectType("CANT_BE_THE_TARGET_OF")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			SetPattern restriction = parameters.get(Parameter.RESTRICTION).getOne(SetPattern.class);
			for(Targetable t: parameters.get(Parameter.OBJECT).getAll(Targetable.class))
				t.cantBeTheTargetOf(restriction);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: objects that can't have the keyword
	 * @eparam ABILITY: the keyword(s) those objects can't have (a Class<?
	 * extends Keyword>)
	 */
	public static final ContinuousEffectType CANT_HAVE_KEYWORD = new ContinuousEffectType("CANT_HAVE_KEYWORD")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			java.util.Collection<Class<? extends Keyword>> abilities = parameters.get(Parameter.ABILITY).getAllClasses(Keyword.class);
			java.util.Collection<GameObject> objects = parameters.get(Parameter.OBJECT).getAll(GameObject.class);

			for(GameObject object: objects)
				for(Class<? extends Keyword> keyword: abilities)
				{
					Keyword granted = null;
					for(Keyword onObject: object.getKeywordAbilities())
						if(keyword.isAssignableFrom(onObject.getClass()))
						{
							granted = onObject;
							break;
						}
					if(granted == null)
						continue;

					if(granted.grantedByID != -1)
					{
						ContinuousEffect gaveThatAbility = state.<ContinuousEffect>get(granted.grantedByID);
						if(gaveThatAbility instanceof FloatingContinuousEffect)
						{
							FloatingContinuousEffect fce = (FloatingContinuousEffect)gaveThatAbility;
							Class<? extends Keyword> keywordClass = granted.getClass();
							if(!fce.dontGrant.containsKey(keywordClass))
								fce.dontGrant.put(keywordClass, new java.util.HashSet<>());
							fce.dontGrant.get(keywordClass).add(object.ID);
						}
					}
				}

			// this is a tad inefficient, but it makes absolutely sure the
			// losing-ability part is performed correctly.
			REMOVE_ABILITY_FROM_OBJECT.apply(state, effect, parameters);
		}

		@Override
		public Layer layer()
		{
			return Layer.ABILITY_ADD_OR_REMOVE;
		}
	};

	/**
	 * @eparam OBJECT: the objects to be changed
	 * @eparam PLAYER: the new controller
	 */
	public static final ContinuousEffectType CHANGE_CONTROL = new ContinuousEffectType("CHANGE_CONTROL")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Player controller = parameters.get(Parameter.PLAYER).getOne(Player.class);
			if(null != controller)
			{
				int controllerID = controller.ID;
				for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
					object.controllerID = controllerID;
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.CONTROL_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the objects to be changed
	 * @eparam FROM: the enum value to change from
	 * @eparam TO: the enum value to change to
	 */
	public static final ContinuousEffectType CHANGE_TEXT = new ContinuousEffectType("CHANGE_TEXT")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		// A note on dependencies and this effect: The rule for dependencies
		// describes one of the conditions for two effects being dependent as
		// being "the effect changes what the other effect does to any of the
		// objects it applies to." We are creatively interpreting the rules such
		// that a text change that doesn't actually cause the text on the object
		// to change is no different from one that does, and therefore two text
		// change effects are only dependent on one another if the parameters to
		// the effect actually change based on the order of those effects. Just
		// like all the other effect types.
		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Enum<?> from = parameters.get(Parameter.FROM).getOne(Enum.class);
			Enum<?> to = parameters.get(Parameter.TO).getOne(Enum.class);

			Set removedObjects = new RemovedObjects();

			for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
			{
				TextChange textChange = new TextChange(from, to);
				object.textChanges.add(textChange);

				java.util.Set<SubType> oldBasicLandTypes = java.util.EnumSet.copyOf(SubType.getBasicLandTypes());
				oldBasicLandTypes.retainAll(SubType.getSubTypesFor(Type.LAND, object.getSubTypes()));

				java.util.Set<SubType> subTypes = object.getSubTypes();
				object.removeSubTypes(subTypes);
				textChange.applyTo(subTypes);
				object.addSubTypes(subTypes);

				java.util.Set<SubType> newBasicLandTypes = java.util.EnumSet.copyOf(SubType.getBasicLandTypes());
				newBasicLandTypes.retainAll(SubType.getSubTypesFor(Type.LAND, object.getSubTypes()));

				java.util.Set<SubType> typesRemoved = java.util.EnumSet.copyOf(oldBasicLandTypes);
				typesRemoved.removeAll(newBasicLandTypes);
				for(SubType type: typesRemoved)
				{
					NonStaticAbility ability = state.game.getIntrinsic(type, object.ID);
					if(object.removeAbility(ability))
						removedObjects.add(ability);
				}

				java.util.Set<SubType> typesAdded = java.util.EnumSet.copyOf(newBasicLandTypes);
				typesAdded.removeAll(oldBasicLandTypes);
				for(SubType type: typesAdded)
					object.addAbility(state.game.getIntrinsic(type, object.ID));
			}

			parameters.put(Parameter.REMOVED_OBJECTS, removedObjects);
		}

		@Override
		public Layer layer()
		{
			return Layer.TEXT_CHANGE;
		}
	};

	/**
	 * @eparam CONTROLLER: who controls the turn
	 * @eparam PLAYER: who is being controlled
	 * @eparam RANGE: when they are being controlled (requires double-generator
	 * idiom so this generator isn't frozen)
	 */
	public static final ContinuousEffectType CONTROL_PLAYER = new ContinuousEffectType("CONTROL_TURN")
	{

		@Override
		public Parameter affects()
		{
			return Parameter.PLAYER;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			SetGenerator duration = parameters.get(Parameter.RANGE).getOne(SetGenerator.class);
			if(duration == null)
				throw new IllegalStateException("RANGE parameter of " + effect.getSourceObject() + "'s CONTROL_TURN didn't contain a SetGenerator.");
			if(duration.evaluate(state, effect.getSourceObject()).isEmpty())
				return;

			Player controller = parameters.get(Parameter.CONTROLLER).getOne(Player.class);
			// 800.4b. ... If a player would be controlled by a player who has
			// left the game, he or she isn't.
			if(controller.outOfGame)
				return;

			Player victim = parameters.get(Parameter.PLAYER).getOne(Player.class);
			state.controlledPlayers.put(victim.ID, controller.ID);
		}

		@Override
		public Layer layer()
		{
			return Layer.CONTROL_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the object(s) who get the abilities
	 * @eparam ABILITY: the instances of abilities to copy onto the objects
	 */
	public static final ContinuousEffectType COPY_ABILITIES_TO_OBJECT = new ContinuousEffectType("COPY_ABILITIES_TO_OBJECT")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Set abilities = parameters.get(Parameter.ABILITY);
			java.util.Set<GameObject> objects = parameters.get(Parameter.OBJECT).getAll(GameObject.class);

			for(GameObject object: objects)
				for(Identified i: abilities.getAll(Identified.class))
				{
					Game.GrantedAbilityKey key = new Game.GrantedAbilityKey(effect.getSourceObject(), i, object.ID);
					Identified physicalAbility = null;
					if(state.game.grantedAbilities.containsKey(key))
					{
						physicalAbility = state.game.physicalState.get(state.game.grantedAbilities.get(key));
					}
					else
					{
						if(i instanceof GameObject)
							physicalAbility = ((GameObject)i).create(state.game);
						else if(i instanceof StaticAbility)
							physicalAbility = ((StaticAbility)i).create(state.game);
						else
							throw new UnsupportedOperationException(i + " is not an ability.");
						state.game.grantedAbilities.put(key, physicalAbility.ID);
					}

					Identified instance;
					if(state.containsIdentified(physicalAbility.ID))
						instance = state.copyForEditing(physicalAbility);
					else
						instance = physicalAbility.clone(state);

					if(instance instanceof NonStaticAbility)
					{
						NonStaticAbility ability = (NonStaticAbility)instance;
						Identified sourceObject = effect.getSourceObject();
						if(sourceObject != null)
							ability.grantedByID = sourceObject.ID;
						object.addAbility(ability);
					}
					else if(instance instanceof Keyword)
					{
						Keyword newAbility = (Keyword)instance;
						newAbility.createdByTimestamp = effect.getTimestamp();
						newAbility.grantedByID = effect.ID;
						object.addAbility(newAbility);
					}
					else if(instance instanceof StaticAbility)
					{
						StaticAbility newAbility = (StaticAbility)instance;

						// Make sure the static ability's continuous effect is
						// in this state
						if(!state.containsIdentified(newAbility.effectID))
							((StaticAbility)physicalAbility).getEffect().clone(state);

						newAbility.createdByTimestamp = effect.getTimestamp();
						newAbility.grantedByID = effect.ID;
						object.addAbility(newAbility);
					}
					else
						throw new UnsupportedOperationException(i + " is not an ability.");
				}
		}

		@Override
		public Layer layer()
		{
			return Layer.ABILITY_ADD_OR_REMOVE;
		}
	};

	/**
	 * @eparam ABILITY: any ability factories for abilities that need to be
	 * added as part of the copy effect (optional)
	 * @eparam OBJECT: any {@link GameObject}s to be changed
	 * @eparam ORIGINAL: the single {@link GameObject} to be copied from
	 * @eparam RETAIN: {@link Characteristics.Characteristic}s to not copy
	 * (optional parameter; default is none)
	 * @eparam TYPE: Any {@link Type}s, {@link SuperType}s, or {@link SubType}s
	 * to add as part of the copying process
	 * @eparam COLOR: If the copying process overwrites the color of the copy,
	 * the new {@link Color} of the object
	 */
	public static final ContinuousEffectType COPY_OBJECT = new ContinuousEffectType("COPY_OBJECT")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			GameObject original = parameters.get(Parameter.ORIGINAL).getOne(GameObject.class);
			// No original object means nothing that can be copied
			if(null == original)
				return;

			Characteristics.Characteristic[] dontCopy = new Characteristics.Characteristic[] {};
			if(parameters.containsKey(Parameter.RETAIN))
				dontCopy = parameters.get(Parameter.RETAIN).getAll(Characteristics.Characteristic.class).toArray(dontCopy);

			for(GameObject target: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
			{
				Game.CopyEffectSnapshotKey key = new Game.CopyEffectSnapshotKey(effect.ID, target.ID);
				CopiableValues snapshot;
				if(state.game.copyEffectSnapshots.containsKey(key))
					snapshot = state.game.copyEffectSnapshots.get(key);
				else
				{
					snapshot = state.game.getCachedSnapshot(original);
					if(snapshot == null)
						snapshot = new CopiableValues(state.game, original, target, false, dontCopy);
					state.game.copyEffectSnapshots.put(key, snapshot);
				}

				// 707.10. If a face-down permanent becomes a copy of another
				// permanent, its copiable values become the copiable values of
				// that permanent, as modified by its face-down status. Its
				// characteristics therefore remain the same: the
				// characteristics listed by the ability or rules that allowed
				// it to be turned face down. ...
				if(null != target.faceDownValues)
					continue;

				target.hasACopyEffect = true;
				snapshot.apply(state, target);
			}

			// 706.8a Some copy effects cause the copy to gain an ability as
			// part of the copying process. This ability becomes part of the
			// copiable values for the copy, along with any other abilities that
			// were copied.
			if(parameters.containsKey(Parameter.ABILITY))
				ADD_ABILITY_TO_OBJECT.apply(state, effect, parameters);

			// 706.8c Some copy effects modify a characteristic as part of the
			// copying process. The final value(s) for that characteristic
			// becomes part of the copiable values for the copy.
			// All the cards that copy and change types add them.
			if(parameters.containsKey(Parameter.TYPE))
				ADD_TYPES.apply(state, effect, parameters);
			// The one card (Fork) that copy and change color sets it.
			if(parameters.containsKey(Parameter.COLOR))
				SET_COLOR.apply(state, effect, parameters);
		}

		@Override
		public Layer layer()
		{
			return Layer.COPY;
		}
	};

	/**
	 * @eparam OBJECT: What objects this applies to.
	 * @eparam COST: Set of ManaSymbols that is the additional cost, or an
	 * amount of colorless mana to add, or EventFactories to add to the object's
	 * costs
	 * @eparam NUMBER: How many times to add the cost [optional; default 1 --
	 * does nothing for EventFactory costs, only for ManaPool costs.]
	 */
	public static final ContinuousEffectType COST_ADDITION = new ContinuousEffectType("COST_ADDITION")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Set objects = parameters.get(Parameter.OBJECT);

			Integer colorlessAmount = parameters.get(Parameter.COST).getOne(Integer.class);
			ManaPool cost = null;
			if(colorlessAmount == null)
				cost = new ManaPool(parameters.get(Parameter.COST).getAll(ManaSymbol.class));
			else
				cost = new ManaPool(colorlessAmount.toString());
			if(parameters.containsKey(Parameter.NUMBER))
				cost = cost.duplicate(parameters.get(Parameter.NUMBER).getOne(Integer.class));

			if(state.manaCostAdditions.containsKey(objects))
				state.manaCostAdditions.get(objects).addAll(cost);
			else
				state.manaCostAdditions.put(objects, cost);

			java.util.Set<EventFactory> extraCosts = parameters.get(Parameter.COST).getAll(EventFactory.class);
			for(GameObject object: objects.getAll(GameObject.class))
				object.getCosts().addAll(extraCosts);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: The sources whose damage can't be prevented. [optional;
	 * default is all objects]
	 */
	public static final ContinuousEffectType DAMAGE_CANT_BE_PREVENTED = new ContinuousEffectType("DAMAGE_CANT_BE_PREVENTED")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			if(parameters.containsKey(Parameter.OBJECT))
				for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
					state.sourcesOfUnpreventableDamage.add(object);
			else
				for(GameObject object: state.getAll(GameObject.class))
					state.sourcesOfUnpreventableDamage.add(object);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * If damage would reduce [player]'s life total to less than [number], it
	 * reduces it to [number] instead.
	 *
	 * @eparam PLAYER: players affected
	 * @eparam NUMBER: minimum life total of those players
	 */
	public static final ContinuousEffectType DAMAGE_CANT_REDUCE_LIFE_TOTAL_TO_LESS_THAN = new ContinuousEffectType("DAMAGE_CANT_REDUCE_LIFE_TOTAL_TO_LESS_THAN")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.PLAYER;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			int number = parameters.get(Parameter.NUMBER).getOne(Integer.class);
			for(Player p: parameters.get(Parameter.PLAYER).getAll(Player.class))
				p.minimumLifeTotalFromDamage = number;
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	public static final class DamageAbility
	{
		public DamagePattern dp;
		public Class<? extends Keyword> k;

		public DamageAbility(DamagePattern dp, Class<? extends Keyword> k)
		{
			this.dp = dp;
			this.k = k;
		}
	}

	/**
	 * @eparam OBJECT: {@link DamagePattern}s describing the damage to affect
	 * @eparam ABILITY: an {@link AbilityFactory} for the ability to create
	 */
	public static final ContinuousEffectType DEAL_DAMAGE_AS_THOUGH_HAS_ABILITY = new ContinuousEffectType("DEAL_DAMAGE_AS_THOUGH_HAS_ABILITY")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			for(DamagePattern dp: parameters.get(Parameter.OBJECT).getAll(DamagePattern.class))
				for(Class<? extends Keyword> f: parameters.get(Parameter.ABILITY).getAllClasses(Keyword.class))
					state.dealDamageAsThoughHasAbility.put(effect.getSourceObject().ID, new DamageAbility(dp, f));
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the object to be modified
	 */
	public static final ContinuousEffectType DEAL_DAMAGE_AS_THOUGH_UNBLOCKED = new ContinuousEffectType("DEAL_DAMAGE_AS_THOUGH_UNBLOCKED")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
				object.setDealDamageAsUnblocked(true);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the objects that will be treated as though they
	 * "do not have" the ability
	 * @eparam EXEMPT: the set of objects that are exempt from the rules of the
	 * ability
	 * @eparam ABILITY: the class literal for the ability the objects are exempt
	 * from (NOTE: does not check hierarchies. only this exact class will be
	 * exempt)
	 */
	public static final ContinuousEffectType EXEMPT_FROM_ABILITY = new ContinuousEffectType("EXEMPT_FROM_ABILITY")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			String ability = parameters.get(Parameter.ABILITY).getOne(Class.class).getName();
			if(!state.abilityExemptions.containsKey(ability))
				state.abilityExemptions.put(ability, new java.util.HashMap<Integer, Set>());
			Set exemptions = parameters.get(Parameter.EXEMPT);
			for(Identified object: parameters.get(Parameter.OBJECT).getAll(Identified.class))
			{
				if(!state.abilityExemptions.get(ability).containsKey(object.ID))
					state.abilityExemptions.get(ability).put(object.ID, Set.fromCollection(exemptions));
				else
					state.abilityExemptions.get(ability).get(object.ID).add(exemptions);
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the cards to give the keyword to
	 * @eparam ABILITY: the keyword class literal to grant
	 */
	public static final ContinuousEffectType GRANT_COSTED_KEYWORD = new ContinuousEffectType("GRANT_COSTED_KEYWORD")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			java.util.Set<Class<? extends Keyword>> abilities = parameters.get(Parameter.ABILITY).getAllClasses(Keyword.class);

			for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
			{
				ManaPool manaCost = object.getManaCost()[0];
				if(manaCost == null)
					continue;

				for(Class<? extends Keyword> keyword: abilities)
				{
					Game.GrantedAbilityKey key = new Game.GrantedAbilityKey(effect.getSourceObject(), keyword, object.ID);
					Keyword ability;
					if(state.game.grantedAbilities.containsKey(key))
					{
						ability = state.game.physicalState.get(state.game.grantedAbilities.get(key));
					}
					else
					{
						ability = org.rnd.util.Constructor.construct(keyword, new Class<?>[] {GameState.class, String.class}, new Object[] {state.game.physicalState, manaCost.toString()});
						state.game.grantedAbilities.put(key, ability.ID);
					}

					Keyword instance;
					if(state.containsIdentified(ability.ID))
						instance = state.copyForEditing(ability);
					else
						instance = ability.clone(state);

					ability.createdByTimestamp = effect.getTimestamp();
					ability.grantedByID = effect.ID;
					object.addAbility(instance);
				}
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.ABILITY_ADD_OR_REMOVE;
		}
	};

	/**
	 * @eparam OBJECT: the object to be looked at
	 * @eparam PLAYER: the player looking (can be more than one)
	 */
	public static final ContinuousEffectType LOOK = new ContinuousEffectType("LOOK")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Set objects = parameters.get(Parameter.OBJECT);
			java.util.Set<Player> players = parameters.get(Parameter.PLAYER).getAll(Player.class);

			for(GameObject object: objects.getAll(GameObject.class))
				for(Player player: players)
					object.setActualVisibility(player, true);
		}

		@Override
		public Layer layer()
		{
			return Layer.PLAYER;
		}
	};
	/**
	 * Allows a player to see the physical version of an object. This is what
	 * you use when a player can "look at" a face down creature.
	 * 
	 * @eparam OBJECT: the object to be looked at
	 * @eparam PLAYER: the player looking (can be more than one)
	 */
	public static final ContinuousEffectType LOOK_PHYSICALLY = new ContinuousEffectType("LOOK_PHYSICALLY")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Set objects = parameters.get(Parameter.OBJECT);
			java.util.Set<Player> players = parameters.get(Parameter.PLAYER).getAll(Player.class);

			for(GameObject object: objects.getAll(GameObject.class))
				for(Player player: players)
					object.setPhysicalVisibility(player, true);
		}

		@Override
		public Layer layer()
		{
			return Layer.PLAYER;
		}
	};
	/**
	 * @eparam OBJECT: What objects this applies to.
	 * @eparam COST: Integer that is the minimum cost
	 */
	public static final ContinuousEffectType COST_MINIMUM = new ContinuousEffectType("COST_MINIMUM")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Set objects = parameters.get(Parameter.OBJECT);

			Integer amount = parameters.get(Parameter.COST).getOne(Integer.class);
			if(state.manaCostMinimums.containsKey(objects))
			{
				int currentMinimum = state.manaCostMinimums.get(objects);
				if(amount > currentMinimum)
					state.manaCostMinimums.put(objects, amount);
			}
			else
				state.manaCostMinimums.put(objects, amount);

			java.util.Set<EventFactory> extraCosts = parameters.get(Parameter.COST).getAll(EventFactory.class);
			for(GameObject object: objects.getAll(GameObject.class))
				object.getCosts().addAll(extraCosts);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: What objects this applies to.
	 * @eparam COST: ManaSymbols representing the reduction in cost. (use
	 * Identity.fromCollection(ManaPool))
	 * @eparam NUMBER: How many times the cost is reduced (single number)
	 * [optional; default is 1].
	 * @eparam COLOR: if present, this effect reduces only the amount of colored
	 * mana paid
	 * @eparam RESTRICTION: if present, this effect can't reduce the amount of
	 * mana a spell/ability costs to play to less than one mana.
	 */
	public static final ContinuousEffectType MANA_COST_REDUCTION = new ContinuousEffectType("MANA_COST_REDUCTION")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Set objects = parameters.get(Parameter.OBJECT);
			ManaPool cost = new ManaPool(parameters.get(Parameter.COST).getAll(ManaSymbol.class));
			if(parameters.containsKey(Parameter.NUMBER))
				cost = cost.duplicate(parameters.get(Parameter.NUMBER).getOne(Integer.class));

			java.util.Map<Set, ManaPool> reductions = state.manaCostReductions;
			if(parameters.containsKey(Parameter.RESTRICTION))
				reductions = state.manaCostRestrictedReductions;
			else if(parameters.containsKey(Parameter.COLOR))
				reductions = state.manaCostColoredReductions;

			if(reductions.containsKey(objects))
				reductions.get(objects).addAll(cost);
			else
				reductions.put(objects, cost);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the objects whose (X) costs are being restricted
	 * @eparam RESTRICTION: what mana can be spent on OBJECT
	 */
	public static final ContinuousEffectType MANA_COST_RESTRICTION = new ContinuousEffectType("MANA_COST_RESTRICTION")
	{

		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			java.util.Set<ManaSymbol> restriction = parameters.get(Parameter.RESTRICTION).getAll(ManaSymbol.class);
			for(GameObject spell: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
			{
				if(spell.manaCostRestrictions == null)
					spell.manaCostRestrictions = new java.util.HashSet<ManaSymbol>();
				spell.manaCostRestrictions.addAll(restriction);
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * [Mana] doesn't empty from [mana pools] as steps and phases end.
	 *
	 * @eparam TYPE: one {@link SetPattern} describing what kind of mana doesn't
	 * empty. The pattern should match one mana symbol. The pattern should not
	 * depend on thisObject as it will be null.
	 * @eparam PLAYER: whose mana pool it doesn't empty from
	 */
	public static final ContinuousEffectType MANA_DOESNT_EMPTY = new ContinuousEffectType("MANA_DOESNT_EMPTY")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.TYPE;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			java.util.Set<Player> players = parameters.get(Parameter.PLAYER).getAll(Player.class);
			SetPattern mana = parameters.get(Parameter.TYPE).getOne(SetPattern.class);

			for(Player p: players)
				state.manaThatDoesntEmpty.get(p.ID).addPattern(mana);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * Since a {@link ContinuousEffect} doesn't follow {@link GameObject}
	 * instances as they move about the game, the way to use this is to add a
	 * {@link PlayPermission} that simply resolves to the desired {@link Player
	 * Players} without doing any location-based logic.
	 *
	 * @eparam OBJECT: the {@link Castable} instances to add permissions to when
	 * those instances can be played from
	 * @eparam PERMISSION: the {@link PlayPermission} instances to add
	 */
	public static final ContinuousEffectType MAY_CAST_LOCATION = new ContinuousEffectType("MAY_CAST_LOCATION")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			PlayPermission permission = parameters.get(Parameter.PERMISSION).getOne(PlayPermission.class);
			permission.setSource(effect.getSourceObject());

			Set objects = parameters.get(Parameter.OBJECT);

			for(Castable castable: objects.getAll(Castable.class))
				castable.addCastablePermissionLocation(permission);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the {@link Castable} instances to add permissions to when
	 * those instances can be played from
	 * @eparam PERMISSION: the {@link PlayPermission} instances to add
	 */
	public static final ContinuousEffectType MAY_CAST_TIMING = new ContinuousEffectType("MAY_CAST_TIMING")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			PlayPermission permission = parameters.get(Parameter.PERMISSION).getOne(PlayPermission.class);
			permission.setSource(effect.getSourceObject());

			Set objects = parameters.get(Parameter.OBJECT);

			for(Castable castable: objects.getAll(Castable.class))
				castable.addCastablePermissionTiming(permission);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * Since a {@link ContinuousEffect} doesn't follow {@link GameObject}
	 * instances as they move about the game, the way to use this is to add a
	 * {@link PlayPermission} that simply resolves to the desired {@link Player
	 * Players} without doing any location-based logic.
	 *
	 * @eparam OBJECT: the {@link Castable} and {@link PlayableAsLand} instances
	 * to add permissions to where those instances can be played from
	 * @eparam PERMISSION: the {@link PlayPermission} instances to add
	 */
	public static final ContinuousEffectType MAY_PLAY_LOCATION = new ContinuousEffectType("MAY_PLAY_LOCATION")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			PlayPermission permission = parameters.get(Parameter.PERMISSION).getOne(PlayPermission.class);
			permission.setSource(effect.getSourceObject());

			Set objects = parameters.get(Parameter.OBJECT);

			for(Castable castable: objects.getAll(Castable.class))
				castable.addCastablePermissionLocation(permission);

			for(PlayableAsLand playable: objects.getAll(PlayableAsLand.class))
				playable.addPlayableAsLandPermissionLocation(permission);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the {@link Castable} and {@link PlayableAsLand} instances
	 * to add permissions to when those instances can be played
	 * @eparam PERMISSION: the {@link PlayPermission} instances to add
	 */
	public static final ContinuousEffectType MAY_PLAY_TIMING = new ContinuousEffectType("MAY_PLAY_TIMING")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			PlayPermission permission = parameters.get(Parameter.PERMISSION).getOne(PlayPermission.class);
			permission.setSource(effect.getSourceObject());

			Set objects = parameters.get(Parameter.OBJECT);

			for(Castable castable: objects.getAll(Castable.class))
				castable.addCastablePermissionTiming(permission);

			for(PlayableAsLand playable: objects.getAll(PlayableAsLand.class))
				playable.addPlayableAsLandPermissionTiming(permission);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam EFFECT: the name of spells whose effects will count this object
	 * @eparam OBJECT: the object which will be counted with an additional name
	 * @eparam NAME: the name of the object the spell will see
	 */
	public static final ContinuousEffectType MODIFY_HAS_NAME = new ContinuousEffectType("MODIFY_HAS_NAME")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			String effectName = parameters.get(Parameter.EFFECT).getOne(String.class);
			String objectName = parameters.get(Parameter.NAME).getOne(String.class);
			GameObject object = parameters.get(Parameter.OBJECT).getOne(GameObject.class);

			state.hasNameModifiers.add(new HasName.HasNameModifier(effectName, object, objectName));
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam PLAYER: the player to act on
	 * @eparam RESTRICTION: the change to the max hand size
	 */
	public static final ContinuousEffectType MODIFY_MAX_HAND_SIZE = new ContinuousEffectType("MODIFY_MAX_HAND_SIZE")
	{

		@Override
		public Parameter affects()
		{
			return Parameter.PLAYER;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			int change = parameters.get(Parameter.RESTRICTION).getOne(Integer.class);
			for(Player player: parameters.get(Parameter.PLAYER).getAll(Player.class))
			{
				Integer curMax = player.getMaxHandSize();
				if(curMax != null)
				{
					player.setMaxHandSize(curMax + change);
				}
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the creatures to affect
	 * @eparam POWER: adjustment to power
	 * @eparam TOUGHNESS: adjustment to toughness
	 */
	public static final ContinuousEffectType MODIFY_POWER_AND_TOUGHNESS = new ContinuousEffectType("MODIFY_POWER_AND_TOUGHNESS")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			int power = Sum.get(parameters.get(Parameter.POWER));
			int toughness = Sum.get(parameters.get(Parameter.TOUGHNESS));

			for(GameObject creature: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
			{
				creature.setPower(creature.getPower() + power);
				creature.setToughness(creature.getToughness() + toughness);
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.POWER_AND_TOUGHNESS;
		}

		@Override
		public SubLayer subLayer()
		{
			return SubLayer.MODIFY;
		}
	};

	/**
	 * @eparam PLAYER: the player(s) getting the mulligan option
	 * @eparam EVENT: an {@link EventFactory} describing what the mulligan
	 * option does
	 */
	public static final ContinuousEffectType MULLIGAN_OPTION = new ContinuousEffectType("MULLIGAN_OPTION")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.PLAYER;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			EventFactory e = parameters.get(Parameter.EVENT).getOne(EventFactory.class);
			for(Player p: parameters.get(Parameter.PLAYER).getAll(Player.class))
				p.mulliganOptions.put(effect.getSourceObject().ID, e);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};
	/**
	 * @eparam COST: the cost to add
	 * @eparam OBJECT: the objects to add the cost to
	 */
	public static final ContinuousEffectType OPTIONAL_ADDITIONAL_COST = new ContinuousEffectType("OPTIONAL_ADDITIONAL_COST")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			java.util.Set<CostCollection> costs = parameters.get(ContinuousEffectType.Parameter.COST).getAll(CostCollection.class);

			for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
				object.optionalAdditionalCosts.addAll(costs);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};
	/**
	 * @eparam PLAYER: the {@link Player} who will be choosing attackers and
	 * what to attack instead of the default
	 */
	public static final ContinuousEffectType OVERRIDE_CHOOSING_ATTACKERS = new ContinuousEffectType("OVERRIDE_CHOOSING_ATTACKERS")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Player chooser = parameters.get(Parameter.PLAYER).getOne(Player.class);
			state.declareAttackersPlayerOverride = chooser.ID;
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam PLAYER: the {@link Player} who will be choosing blockers and what
	 * to block instead of the default
	 */
	public static final ContinuousEffectType OVERRIDE_CHOOSING_BLOCKERS = new ContinuousEffectType("OVERRIDE_CHOOSING_BLOCKERS")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Player chooser = parameters.get(Parameter.PLAYER).getOne(Player.class);
			state.declareBlockersPlayerOverride = chooser.ID;
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the {@link GameObject}s to pair (must only be two
	 * objects)
	 */
	public static final ContinuousEffectType PAIR = new ContinuousEffectType("PAIR")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			java.util.Iterator<GameObject> i = parameters.get(Parameter.OBJECT).getAll(GameObject.class).iterator();
			GameObject first = i.next();
			if(i.hasNext())
			{
				GameObject second = i.next();
				first.setPairedWith(second);
				second.setPairedWith(first);
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.LAYER_ZERO;
		}
	};

	/**
	 * @eparam PLAYER: the player who gets the factories
	 * @eparam NUMBER: the number of additional land actions the player may use
	 * (or leave empty for 'unlimited')
	 */
	public static final ContinuousEffectType PLAY_ADDITIONAL_LANDS = new ContinuousEffectType("PLAY_ADDITIONAL_LANDS")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.PLAYER;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Set numberSet = parameters.get(Parameter.NUMBER);
			Integer number;
			if(numberSet.isEmpty())
				number = null;
			else
				number = Sum.get(numberSet);
			for(Player player: parameters.get(Parameter.PLAYER).getAll(Player.class))
			{
				if(player.totalLandActions != null)
				{
					if(number == null)
						player.totalLandActions = null;
					else
						player.totalLandActions += number;
				}
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * When prohibiting the casting of a spell based on its characteristics, do
	 * NOT prohibit CAST_SPELL_OR_ACTIVATE_ABILITY directly. Instead of using an
	 * EventPattern, use a PlayProhibition. When prohibiting the activation of
	 * an ability, or the casting of a spell based on something other than its
	 * characteristics, use an EventPattern as normal.
	 * 
	 * @eparam PROHIBITION: Any number of {@link EventPattern}s or
	 * {@link ZoneChangePattern}s describing what can't happen, and any number
	 * of {@link PlayProhibition}s describing objects that can't be played/cast
	 * and by whom.
	 */
	public static final ContinuousEffectType PROHIBIT = new ContinuousEffectType("PROHIBIT")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			state.eventProhibitions.addAll(parameters.get(Parameter.PROHIBITION).getAll(EventPattern.class));
			state.zoneChangeProhibitions.addAll(parameters.get(Parameter.PROHIBITION).getAll(ZoneChangePattern.class));
			for(PlayProhibition p: parameters.get(Parameter.PROHIBITION).getAll(PlayProhibition.class))
			{
				p.setSource(effect.getSourceObject());
				state.playProhibitions.add(p);
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the object to remove abilities from
	 * @eparam ABILITY: the class of ability to remove (Optional; default is
	 * remove all)
	 */
	public static final ContinuousEffectType REMOVE_ABILITY_FROM_OBJECT = new ContinuousEffectType("REMOVE_ABILITY_FROM_OBJECT")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Set objects = parameters.get(Parameter.OBJECT);
			Set abilities = parameters.get(Parameter.ABILITY);

			Set removedObjects = new RemovedObjects();

			if(null == abilities)
			{
				for(GameObject object: objects.getAll(GameObject.class))
				{
					for(NonStaticAbility a: object.getNonStaticAbilities())
						removedObjects.add(a);

					for(StaticAbility a: object.getStaticAbilities())
						removedObjects.add(a);

					for(Keyword a: object.getKeywordAbilities())
						removedObjects.add(a);

					object.removeAllAbilities();
				}
			}
			else
			{
				java.util.Set<Class<? extends Identified>> abilityClasses = abilities.getAllClasses(Identified.class);

				for(GameObject object: objects.getAll(GameObject.class))
				{
					for(Class<? extends Identified> ability: abilityClasses)
					{
						if(Keyword.class.isAssignableFrom(ability))
						{
							java.util.Set<Keyword> toRemove = new java.util.HashSet<Keyword>();

							for(Keyword keyword: object.getKeywordAbilities())
								if(ability.isAssignableFrom(keyword.getClass()))
									toRemove.add(keyword);

							for(Keyword keyword: toRemove)
							{
								Set abilitiesGranted = keyword.getAbilitiesGranted();
								if(object.removeAbility(keyword))
								{
									removedObjects.add(keyword);
									removedObjects.addAll(abilitiesGranted);
								}
							}
						}
						else if(NonStaticAbility.class.isAssignableFrom(ability))
						{
							java.util.Set<NonStaticAbility> toRemove = new java.util.HashSet<NonStaticAbility>();

							for(NonStaticAbility nsa: object.getNonStaticAbilities())
								if(ability.isAssignableFrom(nsa.getClass()))
									toRemove.add(nsa);

							for(NonStaticAbility nsa: toRemove)
								if(object.removeAbility(nsa))
									removedObjects.add(nsa);
						}
						else if(StaticAbility.class.isAssignableFrom(ability))
						{
							java.util.Set<StaticAbility> toRemove = new java.util.HashSet<StaticAbility>();

							for(StaticAbility sa: object.getStaticAbilities())
								if(ability.isAssignableFrom(sa.getClass()))
									toRemove.add(sa);

							for(StaticAbility sa: toRemove)
								if(object.removeAbility(sa))
									removedObjects.add(sa);
						}
					}
				}
			}

			if(!removedObjects.isEmpty())
				parameters.put(Parameter.REMOVED_OBJECTS, removedObjects);
		}

		@Override
		public Layer layer()
		{
			return Layer.ABILITY_ADD_OR_REMOVE;
		}
	};

	/**
	 * @eparam OBJECT: The objects to remove types from.
	 * @eparam TYPE: The types, supertypes, and subtypes to remove.
	 */
	public static final ContinuousEffectType REMOVE_TYPES = new ContinuousEffectType("REMOVE_TYPES")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			java.util.Set<GameObject> objects = parameters.get(Parameter.OBJECT).getAll(GameObject.class);
			java.util.Set<SubType> basics = SubType.getBasicLandTypes();

			Set parameter = parameters.get(Parameter.TYPE);
			java.util.Set<Type> types = parameter.getAll(Type.class);
			java.util.Set<SubType> subTypes = parameter.getAll(SubType.class);
			java.util.Set<SuperType> superTypes = parameter.getAll(SuperType.class);
			for(GameObject object: objects)
			{
				boolean wasPlaneswalker = object.getTypes().contains(Type.PLANESWALKER);
				java.util.Map<SubType, Boolean> wasBasic = new java.util.HashMap<SubType, Boolean>();
				for(SubType basic: basics)
					wasBasic.put(basic, object.getSubTypes().contains(basic));

				object.removeSuperTypes(superTypes);
				object.removeTypes(types);
				object.removeSubTypes(subTypes);

				if(!object.getTypes().contains(Type.ARTIFACT))
					object.removeSubTypes(SubType.getSubTypesFor(Type.ARTIFACT, object.getSubTypes()));
				if(!(object.getTypes().contains(Type.CREATURE) || object.getTypes().contains(Type.TRIBAL)))
					object.removeSubTypes(SubType.getSubTypesFor(Type.CREATURE, object.getSubTypes()));
				if(!object.getTypes().contains(Type.ENCHANTMENT))
					object.removeSubTypes(SubType.getSubTypesFor(Type.ENCHANTMENT, object.getSubTypes()));
				if(!object.getTypes().contains(Type.LAND))
					object.removeSubTypes(SubType.getSubTypesFor(Type.LAND, object.getSubTypes()));
				if(!object.getTypes().contains(Type.PLANESWALKER))
				{
					if(wasPlaneswalker)
						object.removeAbility(state.game.getLoyaltyCountersAbility(object.ID));
					object.removeSubTypes(SubType.getSubTypesFor(Type.PLANESWALKER, object.getSubTypes()));
				}
				if(!(object.getTypes().contains(Type.INSTANT) || object.getTypes().contains(Type.SORCERY)))
					object.removeSubTypes(SubType.getSubTypesFor(Type.INSTANT, object.getSubTypes()));

				for(java.util.Map.Entry<SubType, Boolean> entry: wasBasic.entrySet())
					if(entry.getValue() && !object.getSubTypes().contains(entry.getKey()))
						object.removeAbility(state.game.getIntrinsic(entry.getKey(), object.ID));
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.TYPE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the replacement effects
	 */
	public static final ContinuousEffectType REPLACEMENT_EFFECT = new ContinuousEffectType("REPLACEMENT_EFFECT")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Set objects = parameters.get(Parameter.OBJECT);

			for(EventReplacementEffect e: objects.getAll(EventReplacementEffect.class))
			{
				e.setContinuousEffect(effect);
				state.eventReplacementEffects.add(e);
			}

			for(DamageReplacementEffect e: objects.getAll(DamageReplacementEffect.class))
			{
				e.setContinuousEffect(effect);
				state.damageReplacementEffects.add(e);
			}

			for(ZoneChangeReplacementEffect e: objects.getAll(ZoneChangeReplacementEffect.class))
			{
				e.setContinuousEffect(effect);
				state.zoneChangeReplacementEffects.add(e);
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.REPLACEMENT_EFFECTS;
		}
	};

	/**
	 * @eparam OBJECT: the object to reveal
	 */
	public static final ContinuousEffectType REVEAL = new ContinuousEffectType("REVEAL")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Set objects = parameters.get(Parameter.OBJECT);
			for(GameObject object: objects.getAll(GameObject.class))
				for(Player player: state.players)
					object.setActualVisibility(player, true);
		}

		@Override
		public Layer layer()
		{
			return Layer.PLAYER;
		}
	};

	/**
	 * @eparam OBJECT: the object(s) whose color to change
	 * @eparam COLOR: the color(s) to be changed to
	 */
	public static final ContinuousEffectType SET_COLOR = new ContinuousEffectType("SET_COLOR")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			java.util.Collection<Color> colors = parameters.get(Parameter.COLOR).getAll(Color.class);
			if(colors.isEmpty())
				for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
					object.setColors(java.util.EnumSet.noneOf(Color.class));
			else
				for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
					object.setColors(java.util.EnumSet.copyOf(colors));
		}

		@Override
		public Layer layer()
		{
			return Layer.COLOR_CHANGE;
		}
	};

	/**
	 * 208.2b The card may have a static ability that creates a replacement
	 * effect that sets the creature's power and toughness to one of a number of
	 * specific choices as it enters the battlefield or is turned face up. (See
	 * rule 614, "Replacement Effects.") Such an ability is worded
	 * "As [this creature] enters the battlefield . . . ,"
	 * "As [this creature] is turned face up . . . ," or
	 * "[This creature] enters the battlefield as . . ." and lists two or more
	 * specific power and toughness values (and may also list additional
	 * characteristics). The characteristics chosen with these effects affect
	 * the creature's copiable values. (See rule 706.2.) While the card isn't on
	 * the battlefield, its power and toughness are each considered to be 0.
	 *
	 * @eparam OBJECT the object to set the copiable characteristics of
	 * @eparam POWER the power [optional; default is to not set the power;
	 * required when toughness is specified]
	 * @eparam TOUGHNESS the toughness [optional; default is to not set the
	 * toughness; required when power is specified]
	 * @eparam TYPES the types/subtypes to add [optional]
	 * @eparam ABILITY abilities to add, if any [optional]
	 */
	public static final ContinuousEffectType SET_COPIABLE_CHARACTERISTICS = new ContinuousEffectType("SET_COPIABLE_CHARACTERISTICS")
	{

		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			if(parameters.containsKey(Parameter.POWER))
				ContinuousEffectType.SET_POWER_AND_TOUGHNESS.apply(state, effect, parameters);
			if(parameters.containsKey(Parameter.TYPE))
				ContinuousEffectType.ADD_TYPES.apply(state, effect, parameters);
			if(parameters.containsKey(Parameter.ABILITY))
				ContinuousEffectType.ADD_ABILITY_TO_OBJECT.apply(state, effect, parameters);
		}

		@Override
		public Layer layer()
		{
			return Layer.COPY;
		}
	};

	/**
	 * @eparam PLAYER: the player to act on
	 * @eparam RESTRICTION: the new max hand size (leave empty to specify
	 * infinite)
	 */
	public static final ContinuousEffectType SET_MAX_HAND_SIZE = new ContinuousEffectType("SET_MAX_HAND_SIZE")
	{

		@Override
		public Parameter affects()
		{
			return Parameter.PLAYER;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Integer newMax = parameters.get(Parameter.RESTRICTION).getOne(Integer.class);
			for(Player player: parameters.get(Parameter.PLAYER).getAll(Player.class))
				player.setMaxHandSize(newMax);
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * If a card has a static ability that creates a replacement effect that
	 * sets the creature's power and toughness to one of a number of specific
	 * choices as it enters the battlefield or is turned face up, do not use
	 * this effect. Instead, use {@link #SET_COPIABLE_CHARACTERISTICS}.
	 *
	 * @eparam OBJECT: the creatures to affect
	 * @eparam POWER: new power [optional; if parameter not present, power isn't
	 * changed]
	 * @eparam TOUGHNESS: new toughness [optional; if parameter not present,
	 * toughness isn't changed]
	 *
	 * NOTE: at lease one of POWER and TOUGHNESS must be present, or a runtime
	 * exception will be thrown
	 */
	public static final ContinuousEffectType SET_POWER_AND_TOUGHNESS = new ContinuousEffectType("SET_POWER_AND_TOUGHNESS")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			boolean setPower = false;
			int power = 0;
			{
				Set powerSet = parameters.get(Parameter.POWER);
				if(powerSet != null)
				{
					setPower = true;
					power = Sum.get(powerSet);
				}
			}

			boolean setToughness = false;
			int toughness = 0;
			{
				Set toughSet = parameters.get(Parameter.TOUGHNESS);
				if(toughSet != null)
				{
					setToughness = true;
					toughness = Sum.get(toughSet);
				}
			}

			if(!setPower && !setToughness)
				throw new RuntimeException("SET_POWER_AND_TOUGHNESS called without POWER or TOUGHNESS");

			for(GameObject creature: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
			{
				if(setPower)
					creature.setPower(power);
				if(setToughness)
					creature.setToughness(toughness);
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.POWER_AND_TOUGHNESS;
		}

		@Override
		public SubLayer subLayer()
		{
			return SubLayer.SET;
		}
	};

	/**
	 * @eparam OBJECT: the objects to set the p/t of
	 */
	public static final ContinuousEffectType SET_PT_TO_CMC = new ContinuousEffectType("SET_PT_TO_CMC")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
			{
				int cmc = object.getConvertedManaCost()[0];
				object.setPower(cmc);
				object.setToughness(cmc);
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.POWER_AND_TOUGHNESS;
		}

		@Override
		public SubLayer subLayer()
		{
			return SubLayer.SET;
		}
	};

	/**
	 * @eparam OBJECT: the objects to affect
	 * @eparam TYPE: the types to set
	 */
	public static final ContinuousEffectType SET_TYPES = new ContinuousEffectType("SET_TYPES")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Set allTypes = parameters.get(Parameter.TYPE);

			java.util.Set<SubType> basics = SubType.getBasicLandTypes();

			Set removedObjects = new RemovedObjects();

			java.util.Set<SuperType> superTypes = allTypes.getAll(SuperType.class);
			java.util.Set<Type> types = allTypes.getAll(Type.class);
			java.util.Set<SubType> subTypes = allTypes.getAll(SubType.class);
			java.util.Set<SubType> artifactTypes = SubType.getSubTypesFor(Type.ARTIFACT, subTypes);
			java.util.Set<SubType> creatureTypes = SubType.getSubTypesFor(Type.CREATURE, subTypes);
			java.util.Set<SubType> enchantmentTypes = SubType.getSubTypesFor(Type.ENCHANTMENT, subTypes);
			java.util.Set<SubType> landTypes = SubType.getSubTypesFor(Type.LAND, subTypes);
			java.util.Set<SubType> spellTypes = SubType.getSubTypesFor(Type.SORCERY, subTypes);
			java.util.Set<SubType> planeswalkerTypes = SubType.getSubTypesFor(Type.PLANESWALKER, subTypes);

			boolean removeSuperTypes = !superTypes.isEmpty();
			boolean removeTypes = !types.isEmpty();
			boolean removeArtifactTypes = ((!types.isEmpty() && !types.contains(Type.ARTIFACT)) || !artifactTypes.isEmpty());
			boolean removeCreatureTypes = ((!types.isEmpty() && !types.contains(Type.CREATURE) && !types.contains(Type.TRIBAL)) || !creatureTypes.isEmpty());
			boolean removeEnchantmentTypes = ((!types.isEmpty() && !types.contains(Type.ENCHANTMENT)) || !enchantmentTypes.isEmpty());
			boolean removeLandTypes = ((!types.isEmpty() && !types.contains(Type.LAND)) || !landTypes.isEmpty());
			boolean removeSpellTypes = ((!types.isEmpty() && !types.contains(Type.INSTANT) && !types.contains(Type.SORCERY)) || !spellTypes.isEmpty());
			boolean removePlaneswalkerTypes = ((!types.isEmpty() && !types.contains(Type.PLANESWALKER)) || !planeswalkerTypes.isEmpty());

			for(GameObject object: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
			{
				if(removeSuperTypes)
				{
					object.removeSuperTypes(object.getSuperTypes());
					object.addSuperTypes(superTypes);
				}

				if(removeTypes)
				{
					boolean wasPlaneswalker = object.getTypes().contains(Type.PLANESWALKER);
					object.removeTypes(object.getTypes());
					object.addTypes(types);

					if(wasPlaneswalker && !object.getTypes().contains(Type.PLANESWALKER))
					{
						StaticAbility loyaltyCountersAbility = state.game.getLoyaltyCountersAbility(object.ID);
						if(object.removeAbility(loyaltyCountersAbility))
							removedObjects.add(loyaltyCountersAbility);
					}
					else if(!wasPlaneswalker && object.getTypes().contains(Type.PLANESWALKER))
						object.addAbility(state.game.getLoyaltyCountersAbility(object.ID));
				}

				if(removeArtifactTypes)
				{
					object.removeSubTypes(SubType.getSubTypesFor(Type.ARTIFACT, object.getSubTypes()));
					if(object.getTypes().contains(Type.ARTIFACT))
						object.addSubTypes(artifactTypes);
				}

				if(removeCreatureTypes)
				{
					object.removeSubTypes(SubType.getSubTypesFor(Type.CREATURE, object.getSubTypes()));
					if(object.getTypes().contains(Type.CREATURE) || object.getTypes().contains(Type.TRIBAL))
						object.addSubTypes(creatureTypes);
				}

				if(removeEnchantmentTypes)
				{
					object.removeSubTypes(SubType.getSubTypesFor(Type.ENCHANTMENT, object.getSubTypes()));
					if(object.getTypes().contains(Type.ENCHANTMENT))
						object.addSubTypes(enchantmentTypes);
				}

				if(removeLandTypes)
				{
					java.util.Map<SubType, Boolean> wasBasic = new java.util.HashMap<SubType, Boolean>();
					for(SubType basic: basics)
						wasBasic.put(basic, object.getSubTypes().contains(basic));

					object.removeSubTypes(SubType.getSubTypesFor(Type.LAND, object.getSubTypes()));
					if(object.getTypes().contains(Type.LAND))
					{
						java.util.Set<SubType> s = new java.util.HashSet<SubType>(landTypes);
						s.removeAll(object.getSubTypes());
						s.retainAll(SubType.getBasicLandTypes());
						object.addSubTypes(landTypes);
						if(!s.isEmpty())
						{
							// 305.7. If an effect changes a land's subtype to
							// one or more of the basic land types, the land no
							// longer has its old land type. It loses all
							// abilities generated from its rules text and its
							// old land types, and it gains the appropriate mana
							// ability for each new basic land type. Note that
							// this doesn't remove any abilities that were
							// granted to the land by other effects.
							for(NonStaticAbility a: object.getPhysical().getNonStaticAbilities())
								if(object.removeAbility(a))
									removedObjects.add(a);
							for(StaticAbility a: object.getPhysical().getStaticAbilities())
								if(object.removeAbility(a))
									removedObjects.add(a);
							for(Keyword a: object.getPhysical().getKeywordAbilities())
								if(object.removeAbility(a))
									removedObjects.add(a);
						}
					}

					for(java.util.Map.Entry<SubType, Boolean> entry: wasBasic.entrySet())
					{
						if(entry.getValue() && !object.getSubTypes().contains(entry.getKey()))
						{
							NonStaticAbility intrinsicAbility = state.game.getIntrinsic(entry.getKey(), object.ID);
							if(object.removeAbility(intrinsicAbility))
								removedObjects.add(intrinsicAbility);
						}
						else if(!entry.getValue() && object.getSubTypes().contains(entry.getKey()))
							object.addAbility(state.game.getIntrinsic(entry.getKey(), object.ID));
					}
				}

				if(removeSpellTypes)
				{
					object.removeSubTypes(SubType.getSubTypesFor(Type.SORCERY, object.getSubTypes()));
					if(object.getTypes().contains(Type.INSTANT) || object.getTypes().contains(Type.SORCERY))
						object.addSubTypes(spellTypes);
				}

				if(removePlaneswalkerTypes)
				{
					object.removeSubTypes(SubType.getSubTypesFor(Type.PLANESWALKER, object.getSubTypes()));
					if(object.getTypes().contains(Type.PLANESWALKER))
						object.addSubTypes(planeswalkerTypes);
				}
			}

			if(!removedObjects.isEmpty())
				parameters.put(Parameter.REMOVED_OBJECTS, removedObjects);
		}

		@Override
		public Layer layer()
		{
			return Layer.TYPE_CHANGE;
		}
	};

	/**
	 * @eparam ACTION: SpecialActionFactory objects to add to the state
	 * @eparam PLAYER: the player(s) who will get the special action
	 */
	public static final ContinuousEffectType SPECIAL_ACTION = new ContinuousEffectType("SPECIAL_ACTION")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			Set players = parameters.get(Parameter.PLAYER);

			Player priority = state.getPlayerWithPriority();

			if(priority != null && players.contains(priority))
				for(SpecialActionFactory factory: parameters.get(Parameter.ACTION).getAll(SpecialActionFactory.class))
					// Kamikaze: I really hope this cast is ok, because I'm
					// changing ContinuousEffect.getSourceObject() to an
					// Identified, but this really needs to be a GameObject.
					state.specialActionFactories.put(factory, (GameObject)effect.getSourceObject());
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam PROHIBITION: the replacement effect stopper
	 */
	public static final ContinuousEffectType STOP_REPLACEMENT_EFFECT = new ContinuousEffectType("STOP_REPLACEMENT_EFFECT")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			state.eventReplacementEffectStoppers.addAll(parameters.get(Parameter.PROHIBITION).getAll(EventReplacementEffectStopper.class));
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam PROHIBITION: the triggered ability stopper
	 */
	public static final ContinuousEffectType STOP_TRIGGERED_ABILITY = new ContinuousEffectType("STOP_TRIGGERED_ABILITY")
	{
		@Override
		public Parameter affects()
		{
			return null;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			state.eventTriggeredAbilityStoppers.addAll(parameters.get(Parameter.PROHIBITION).getAll(EventTriggeredAbilityStopper.class));
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	/**
	 * @eparam OBJECT: the creatures to affect
	 */
	public static final ContinuousEffectType SWITCH_POWER_AND_TOUGHNESS = new ContinuousEffectType("SWITCH_POWER_AND_TOUGHNESS")
	{
		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			for(GameObject creature: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
			{
				int swap = creature.getPower();
				creature.setPower(creature.getToughness());
				creature.setToughness(swap);
			}
		}

		@Override
		public Layer layer()
		{
			return Layer.POWER_AND_TOUGHNESS;
		}

		@Override
		public SubLayer subLayer()
		{
			return SubLayer.SWITCH;
		}
	};

	/**
	 * @eparam OBJECT: the objects whose (X) costs are being restricted
	 * @eparam RESTRICTION: a ManaType defining what type of mana must be spent
	 * on (X)
	 */
	public static final ContinuousEffectType X_RESTRICTION = new ContinuousEffectType("X_RESTRICTION")
	{

		@Override
		public Parameter affects()
		{
			return Parameter.OBJECT;
		}

		@Override
		public void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters)
		{
			ManaSymbol.ManaType restriction = parameters.get(Parameter.RESTRICTION).getOne(ManaSymbol.ManaType.class);
			for(GameObject spell: parameters.get(Parameter.OBJECT).getAll(GameObject.class))
				spell.xRestriction = restriction;
		}

		@Override
		public Layer layer()
		{
			return Layer.RULE_CHANGE;
		}
	};

	private String toString;

	public ContinuousEffectType(String name)
	{
		this.toString = name;
	}

	/**
	 * @return The parameter from the continuous effects parameters map that
	 * represents the objects this effect will apply to. This will return null
	 * if and only if the layer is rule change.
	 */
	public abstract Parameter affects();

	public abstract void apply(GameState state, ContinuousEffect effect, java.util.Map<Parameter, Set> parameters);

	/**
	 * Which layer do effects of this type apply in?
	 */
	public abstract Layer layer();

	/**
	 * Which sub-layer do effects of this type apply in? (Only override this for
	 * effects in layer POWER_AND_TOUGHNESS)
	 */
	public SubLayer subLayer()
	{
		return null;
	}

	@Override
	public String toString()
	{
		return this.toString;
	}
}
