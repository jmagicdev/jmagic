package org.rnd.jmagic.engine;

import org.rnd.jmagic.engine.generators.*;

/**
 * A continuous effect which is not attached to a StaticAbility and has an
 * expiration.
 */
public class FloatingContinuousEffect extends ContinuousEffect
{
	/**
	 * When this continuous effect should expire. The first time
	 * expires.evaluate() returns a non-empty set, this effect will be removed
	 * from the set of floating effects in the GameState. By default, expires
	 * will evaluate to non-empty if the current step is any player's cleanup
	 * step.
	 */
	public SetGenerator expires;

	/**
	 * For damage prevention effects that prevent a specific amount of damage,
	 * the amount of damage that is left for them to prevent. This isn't a
	 * member of DamageReplacementEffect because that class is entirely
	 * nonphysical.
	 */
	public int damage;

	/**
	 * Number of times this effect can be used. Set this to -1 to mean that this
	 * effect doesn't have a set number of uses.
	 */
	public int uses;

	/** The event which created this FCE */
	public Event sourceEvent;

	public int timestamp;

	/** The physical turn in which this effect was created. */
	public Turn turnCreated;

	/**
	 * for implementing "can't have" effects
	 * 
	 * keys are keyword classes, values are lists of objects not to grant that
	 * keyword
	 */
	public java.util.Map<Class<? extends Keyword>, java.util.Set<Integer>> dontGrant;

	/**
	 * Constructs a floating continuous effect that does nothing, lasts until
	 * end of turn, and is never used up.
	 * 
	 * @param game The game in which this effect should exist.
	 * @param name The text of the effect.
	 */
	public FloatingContinuousEffect(Game game, String name)
	{
		super(game.physicalState, name);
		this.expires = EndMostFloatingEffects.instance();
		this.damage = -1;
		this.dontGrant = new java.util.HashMap<>();
		this.uses = -1;
		this.sourceEvent = null;
		this.timestamp = -1;
	}

	public void addDamagePreventionShield(SetGenerator target, int damage)
	{
		DamageReplacementEffect prevent = new DamagePreventionShield(this.game, target, damage);

		ContinuousEffect.Part part = new ContinuousEffect.Part(ContinuousEffectType.REPLACEMENT_EFFECT);
		part.parameters.put(ContinuousEffectType.Parameter.OBJECT, Identity.instance(prevent));

		this.parts.add(part);
		this.damage = damage;
	}

	@Override
	public boolean canApply()
	{
		return true;
	}

	/** Java-copies this effect. */
	@Override
	public FloatingContinuousEffect clone(GameState state)
	{
		return (FloatingContinuousEffect)super.clone(state);
	}

	/** @return The version of this effect present in the game's physical state. */
	@Override
	public FloatingContinuousEffect getPhysical()
	{
		return (FloatingContinuousEffect)super.getPhysical();
	}

	/** @return The source of the event that created this effect. */
	@Override
	public Identified getSourceObject()
	{
		return this.sourceEvent.getSource();
	}

	/**
	 * 613.6b A continuous effect generated by the resolution of a spell or
	 * ability receives a timestamp at the time it's created.
	 */
	@Override
	public int getTimestamp()
	{
		// This timestamp is assigned when the effect is created, in
		// EventType.CREATE_FLOATING_CONTINUOUS_EFFECT.
		return this.timestamp;
	}
}
